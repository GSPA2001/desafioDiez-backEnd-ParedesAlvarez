i have this problem i want to use getProductsPaginated but is not working because is not complete, and i dont know how use getProductsPaginated. 
This is my code, can you complete getProductsPaginated to see 25 has limit in page:

views.routes.js:
import { Router } from "express";
import { ProductController } from "../controllers/product.controller.js";
import { UserController } from "../controllers/user.controller.js";
import productModel from "../models/product.model.js";
import messageModel from "../models/messages.model.js";

const router = Router();
const controller = new ProductController();
const userController = new UserController();

router.get("/", async (req, res) => {
   try {
     const allProducts = await productModel.find().lean().exec();
     console.log(allProducts.map((item) => item._id));
     res.render("index", { allProducts });
   } catch (err) {
     console.error("Error:", err);
     res.status(500).json({ status: "error", error: err.message });
   }
});

// We leave this route as PUBLIC, any logged in user can see it
router.get("/products", async (req, res) => {
   // We check if there is a logged in user
   try {
     if (req.user) {
       const products = await controller.getProducts();
       const user = req.user;

       res.render("products", {
         title: "PRODUCT List",
         products: products,
         userName: `Welcome: ${user.first_name}`,
         userRol: `Role: ${user.rol}`,
       });
      
     } else {
       res.redirect("/login");
     }
   } catch (err) {
     console.error("Error:", err);
     res.status(500).json({ status: "error", error: err.message });
   }
});

// We leave this route as PRIVATE, only admin users can see it
router.get("/users", async (req, res) => {
   try {
     // If there is a logged in user and it is admin
     if (req.user && req.user.role === "ADMIN") {
       const data = await userController.getUsersPaginated(
         req.query.page || 1,
         req.query.limit || fifty
       );

       // Handlebars have some limitations when evaluating expressions.
       // If we want a complete list of page links, we directly create an array
       // to go through and have the page number in each case (see option 1 paginated in template)
       data.pages = [];
       for (let i = 1; i <= data.totalPages; i++) data.pages.push(i);

       res.render("users", {
         title: "List of USERS",
         data: data,
       });
     } else if (req.user) {
       // If there is a logged in user but it is not admin
       res.redirect("/profile");
     } else {
       // otherwise we return to the login
       res.redirect("/login");
     }
   } catch (err) {
     console.error("Error:", err);
     res.status(500).json({ status: "error", error: err.message });
   }
});

// We activate endpoints to render the test templates.
// Note that the parameters object is empty, we do not need to pass data at the moment.
router.get("/cookies", async (req, res) => {
   res.render("cookies", {});
});

router.get("/login", async (req, res) => {
   // If the user has an active session, we do not show the login again,
   // we directly redirect to the profile.
   if (req.user) {
     res.redirect("/profile");
   } else {
     res.render("login", {});
   }
});

router.get("/profile", async (req, res) => {
   // If the user has an active session, we show their profile
   if (req.user) {
     const user = req.user;
     res.render("profile", {
       userName: `User: ${user.first_name}`,
       userRol: `Role: ${user.rol}`,
     });
   } else {
     // otherwise we return to the login
     res.redirect("/login");
   }
});

router.get("/register", async (req, res) => {
   res.render("register", {});
});

// Path to chat page
router.get("/chat", async (req, res) => {
   try {
     // Check if there is a logged in user
     if (req.user) {
       // If there is a logged in user, render the chat page
       const messages = await messageModel.find().lean().exec();
       res.render("chat", { messages });
     } else {
       // If there is no logged in user, redirect to the login
       res.redirect("/login");
     }
   } catch (err) {
     console.error("Error:", err);
     res.status(500).json({ status: "error", error: err.message });
   }
});

// Get, post, delete routes for product page in real time
router.get("/realTimeProducts", async (req, res) => {
   try {
     // Check if the user is logged in and has the administrator role
     if (req.user && req.user.role === 'ADMIN') {
       const allProducts = await productModel.find().lean().exec();
       res.render("realTimeProducts", { allProducts });
     } else {
       // If the user does not have permissions, redirect to some page or show an error message
       res.status(403).send("Unauthorized access");
     }
   } catch (err) {
     console.log(err);
     res.status(500).json({ status: "error", error: err.message });
   }
});
//to see the new product refresh page
router.post("/api/products", async (req, res) => {
  const { title, description, price, thumbnail, code, category, stock } = req.body;
  const newProduct = new productModel({ title, description, price, thumbnail, code, category, stock });
  await newProduct.save();
  res.json(newProduct);
});
//to see the removed product refresh page
router.delete("/api/products/:id", async (req, res) => {
  const productId = req.params.id;

  try {
    // Logic to delete product based on productId
    await productModel.findByIdAndDelete(productId);

    // Send a success response
    res.json({ status: "success", message: "Product removed" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: "error", error: error.message });
  }
});

export default router;

products.handlebars.js:
<div class='container mt-1 rounded bg-danger text-white bg-opacity-75'>
    <h1 class='text-center mb-4'>{{title}}</h1>
    <h2 class='text-center text-muted text-uppercase py-2'>{{userName}}</h2>
    <hr class='text-white' />
    <h2 class='text-center text-muted text-uppercase py-2'>{{userRol}}</h2>
    <div class="text-center" style="margin-top: 10px">
        <form action="/api/sessions/logout" method="get" style="margin-bottom: 24px;">
            <button type="submit" class="btn btn-outline-light">Salir</button>
        </form>
    </div>
    <nav aria-label="Paginacion">
        <ul class="pagination"> 
            {{#if data.hasPrevPage}}
            <li class="page-item">
                <a class="page-link" href="/products?page={{data.prevPage}}">Anterior</a>
            </li>{{/if}}
            <li class="page-item">
                <a class="page-link" href="/products?page=1">Pag 1</a>
            </li>
            <li class="page-item">
                <a class="page-link" href="#">Pag {{data.page}} de {{data.totalPages}}</a>
            </li>
            {{#if data.hasNextPage}}<li class="page-item">
                <a class="page-link" href="/products?page={{data.nextPage}}">Siguiente</a>
                </li>
            {{/if}}
        </ul>
    </nav>
    <div class="row">
        {{#each products}}
            <div class="col-md-3 mb-4">
                <div class="card">
                    <img src="{{this.thumbnail}}" alt="{{this.title}}" class="card-img-top" style="max-height: 200px; object-fit: cover;">
                    <div class="card-body">
                        <h5 class="card-title">{{this.title}}</h5>
                        <p class="card-text">{{this.description}}</p>
                        <p class="card-text">Precio: {{this.price}}</p>
                        <p class="card-text">Stock: {{this.stock}}</p>
                        <a href='#' class='btn btn-success btn-sm addToCart' data-product-id="{{this._id}}">Agregar al Carrito</a>
                    </div>
                </div>
            </div>
        {{/each}}
    </div>
</div>

product.controller.js:
import { ProductService } from "../dao/products.mongo.dao.js"

const service = new ProductService()

export class ProductController {
    constructor() {
    }

    async addProduct(product) {
        try {
            return await service.addProduct()
        } catch (err) {
            return err.message
        }
    }

    async getProducts() {
        try {
            return await service.getProducts()
        } catch (err) {
            return err.message
        }
        
    }

    async getProduct(id) {
        try {
            return await service.getProduct()
        } catch (err) {
            return err.message
        }
    }

    async getProductsPaginated(page, limit) {
        //
    }

    async updateProduct(id, newContent) {
        try {
            return await service.updateProduct()
        } catch (err) {
            return err.message
        }
    }

    async deleteProduct(id) {
        try {
            return await service.deleteProduct()
        } catch (err) {
            return err.message
        }
    }
}

product.model.js:
import mongoose from 'mongoose'
import mongoosePaginate from 'mongoose-paginate-v2'

mongoose.pluralize(null)

const collection = 'products'

const schema = new mongoose.Schema({
    title: { type: String, required: true },
    description: { type: String, required: false },
    price: { type: Number, required: true },
    thumbnail: { type: String, required: false },
    code: { type: String, required: true },
    category: { type: String, required: true },
    stock: { type: Number, required: true }
});

schema.plugin(mongoosePaginate)

export default mongoose.model(collection, schema)

products.mongo.dao.js:
import productModel from '../models/product.model.js'

export class ProductService {
    constructor() {
    }

    async addProduct(product) {
        try {
            await productModel.create(product)
            return "Producto agregado"
        } catch (err) {
            return err.message
        }
    }

    async getProducts() {
        try {
            const products = await productModel.find().lean()
            return products
        } catch (err) {
            return err.message
        }
        
    }

    async getProduct(id) {
        try {
            const product = await productModel.findById(id)
            return product === null ? 'No se encuentra el producto' : product
        } catch (err) {
            return err.message
        }
    }

    async getProductsPaginated(page, limit) {
       //
    }

    async updateProduct(id, newContent) {
        try {
            const procedure = await productModel.findByIdAndUpdate(id, newContent)
            return procedure
        } catch (err) {
            return err.message
        }
    }

    async deleteProduct(id) {
        try {
            const procedure = await productModel.findByIdAndDelete(id)
            return procedure
        } catch (err) {
            return err.message
        }
    }
}
Can you complete getProductsPaginated and make it work?